<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Salibandyn taktiikkataulu – demo</title>
  <!--
    Tämä versio toteuttaa pyydetyt muutokset:
    1) Polun piirron lopetus VÄLILYÖNNILLÄ (Space) – ei tuplaklikkausta.
    2) Kenttä piirtyy sisään → maalin taakse jää tilaa piirtää.
    3) Maali alkaa samasta x-koordinaatista kuin maalialue (crease) → maali pysyy sen sisällä.
    4) 5v5-asettelun drag-ongelma korjattu (Group.x/y = pelaajan sijainti, sisäiset objektit keskellä).
    5) Maalivahti poistettu 5v5-asettelusta.
    6) Pelaajamerkinnät: VL, KH, OL, VP, OP. Asettelu kuten jääkiekossa.
    7) CSS on erillisessä tiedostossa: tyyli.css
  -->
  <link rel="stylesheet" href="tyyli.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"> 

</head>

<nav class="topnav" id="myTopnav"> 
        <a href="tacticalboard.html" class="nav-link">Taktiikkataulu</a>

    <a href="index.html" class="nav-link">Koti</a> 

    <a href="hinnasto.html" class="nav-link">Hinnasto & Aukioloajat</a> 

    <a href="galleria.html" class="nav-link">Galleria</a> 

    <a href="yhteystiedot.html" class="nav-link">Yhteystiedot</a> 

    <a href="javascript:void(0);" class="icon" onclick="myFunction()"> 

      <i class="fa fa-bars"></i> 

    </a> 

</nav> 

<body>
  <header>
    <div class="toolbar">
      <h1>Salibandyn taktiikkataulu</h1>
      <button id="selectModeBtn" title="Valitse/siirrä (V)">Valitse</button>
      <button id="pathModeBtn" title="Piirrä liikerata (P)">Polku</button>
      <button id="ballModeBtn" title="Lisää/siirrä pallo (B)">Pallo</button>
      <button id="animateBtn" title="Animoi valitut (A)">Animoi</button>
      <span class="spacer"></span>
      <button id="addTeamsBtn" title="Lisää kaksi 5 pelaajan joukkuetta (ilman mv)">Lisää 5v5</button>
      <button id="clearBtn" title="Tyhjennä kenttä">Tyhjennä</button>
      <button id="saveBtn" title="Lataa JSON">Tallenna</button>
      <label class="file-btn" for="loadInput" title="Lataa JSON">Lataa <input id="loadInput" type="file" accept="application/json" hidden /></label>
      <span class="badge">Beta-pohja</span>
    </div>
  </header>

  <main>
    <section id="board-wrap">
      <div id="container"></div>
      <p class="hint">
        Vihjeet: <strong>Polku</strong>-tilassa klikkaa kenttää lisätäksesi pisteitä; paina
        <kbd>VÄLILYÖNTI</kbd> lopettaaksesi polun. Klikkaa pelaajaa valitaksesi sen.
        Paina <strong>Animoi</strong> siirtääksesi valitut pelaajat valituille radoille.
        Näppäimet: <kbd>V</kbd> Valitse, <kbd>P</kbd> Polku, <kbd>B</kbd> Pallo, <kbd>Del</kbd> Poista.
      </p>
      <div class="palette">
        Pelaajien väri:
        <div class="color" data-color="#5ec8ff" style="background:#5ec8ff"></div>
        <div class="color" data-color="#ff7aa2" style="background:#ff7aa2"></div>
        <div class="color" data-color="#9aff7a" style="background:#9aff7a"></div>
        <div class="color" data-color="#ffd36d" style="background:#ffd36d"></div>
      </div>
    </section>
    <footer>
      Tehty <a href="https://konvajs.org/" target="_blank" rel="noreferrer">Konva.js</a>-kirjastolla. Muokkaa vapaasti (undo/redo, vaiheet, vienti yms.).
    </footer>
  </main>

  <!-- Konva.js CDN -->
  <script src="https://cdn.jsdelivr.net/npm/konva@9.3.13/konva.min.js"></script>
  <script>
  // ------------------------------
  // ASETUKSET JA TILA
  // ------------------------------
  const BOARD_W = 1100; // koko koordinaatistolle (laajempi kuin varsinainen kenttä)
  const BOARD_H = 560;

  // Kenttä piirretään sisemmäksi → maalin taakse jää tilaa
  const FIELD_MARGIN_X = 70;  // vasen/oikea marginaali
  const FIELD_MARGIN_Y = 30;  // ylä/ala marginaali
  const FIELD_W = BOARD_W - FIELD_MARGIN_X * 2;
  const FIELD_H = BOARD_H - FIELD_MARGIN_Y * 2;

  // Tila
  let mode = 'select'; // 'select' | 'path' | 'ball'
  let currentColor = '#5ec8ff';
  let paths = [];   // {node:Konva.Arrow, points:number[]}
  let players = []; // {node:Konva.Group, team:string, role:string}
  let selected = new Set();
  let ball = null;

  // Konva Stage & Layerit
  const container = document.getElementById('container');
  const stage = new Konva.Stage({ container: 'container', width: BOARD_W, height: BOARD_H });
  const fieldLayer = new Konva.Layer();
  const pathLayer = new Konva.Layer();
  const playerLayer = new Konva.Layer();
  stage.add(fieldLayer, pathLayer, playerLayer);

  // ------------------------------
  // KENTÄN PIIRTO
  // ------------------------------
  function drawField(){
    fieldLayer.destroyChildren();

    // Tausta-alue (koko canvas) – tummempi
    fieldLayer.add(new Konva.Rect({ x:0, y:0, width:BOARD_W, height:BOARD_H, fill:'#0b1f22' }));

    // Varsinainen kenttä sisemmäs
    const field = new Konva.Rect({
      x: FIELD_MARGIN_X,
      y: FIELD_MARGIN_Y,
      width: FIELD_W,
      height: FIELD_H,
      cornerRadius: 30,
      fill: '#0a2430',
      stroke: '#7fd7ff33',
      strokeWidth: 2,
    });
    fieldLayer.add(field);

    // Keskiviiva ja keskiympyrä
    fieldLayer.add(new Konva.Line({
      points: [FIELD_MARGIN_X + FIELD_W/2, FIELD_MARGIN_Y + 10, FIELD_MARGIN_X + FIELD_W/2, FIELD_MARGIN_Y + FIELD_H - 10],
      stroke: '#79d2ff55', dash: [8,8]
    }));
    fieldLayer.add(new Konva.Circle({ x: FIELD_MARGIN_X + FIELD_W/2, y: FIELD_MARGIN_Y + FIELD_H/2, radius: 38, stroke: '#79d2ff66' }));
    fieldLayer.add(new Konva.Circle({ x: FIELD_MARGIN_X + FIELD_W/2, y: FIELD_MARGIN_Y + FIELD_H/2, radius: 2, fill: '#79d2ffcc' }));

    // Maalialueet (isot neliöt)
    const creaseInset = 10;
    const creaseW = 90, creaseH = 60;
    const leftCreaseX  = FIELD_MARGIN_X + creaseInset;
    const rightCreaseX = FIELD_MARGIN_X + FIELD_W - creaseInset - creaseW;
    const creaseY = FIELD_MARGIN_Y + FIELD_H/2 - creaseH/2;

    fieldLayer.add(new Konva.Rect({ x:leftCreaseX,  y:creaseY, width:creaseW, height:creaseH, stroke:'#79d2ff66' }));
    fieldLayer.add(new Konva.Rect({ x:rightCreaseX, y:creaseY, width:creaseW, height:creaseH, stroke:'#79d2ff66' }));

    // Maalit (punaiset neliöt) – alkavat samasta x:stä kuin crease → maali pysyy sisällä
    const goalW = 20, goalH = 40;
    const leftGoalX  = leftCreaseX;
    const rightGoalX = rightCreaseX + creaseW - goalW; // oikealla maali "sisäreunasta" sisään
    const goalY = FIELD_MARGIN_Y + FIELD_H/2 - goalH/2;

    fieldLayer.add(new Konva.Rect({ x:leftGoalX,  y:goalY, width:goalW, height:goalH, stroke:'#ff8aa3aa' }));
    fieldLayer.add(new Konva.Rect({ x:rightGoalX, y:goalY, width:goalW, height:goalH, stroke:'#ff8aa3aa' }));

    fieldLayer.draw();
  }
  drawField();

  // ------------------------------
  // APUFUNKTIOT – PELAAJAT, PALLO, VALINNAT
  // ------------------------------
  function createPlayer(x,y,color,label){
    // Circle/Text keskitetty (0,0), Group on (x,y) → drag toimii oikein
    const radius = 14;
    const circle = new Konva.Circle({ x:0, y:0, radius, fill:color, stroke:'#00000055', strokeWidth:2, shadowColor:'#000', shadowBlur:6, shadowOpacity:.25 });
    const text = new Konva.Text({ x:-12, y:-8, text:label||'', fontSize:14, fontStyle:'700', fill:'#00131a' });

    const group = new Konva.Group({ x, y, draggable:true });
    group.add(circle, text);
    group.cache();

    // Rajaa drag koko canvas-alueelle (jotta voi liikkua myös kentän ulkopuolella/maalin takana)
    group.on('dragmove', () => { constrainToCanvas(group, radius); playerLayer.batchDraw(); });

    group.on('mousedown', (e)=>{
      if (mode !== 'select') return;
      const multi = e.evt.shiftKey || e.evt.metaKey || e.evt.ctrlKey;
      if (!multi) { clearSelection(); }
      toggleSelection(group);
    });

    group.toObject = () => ({ x: group.x(), y: group.y(), color, label });

    playerLayer.add(group);
    players.push({ node: group, team: color, role: label || '' });
    return group;
  }

  function createBall(x,y){
    const node = new Konva.Circle({ x, y, radius:6, fill:'#ffe38d', stroke:'#00000066', strokeWidth:1.5, draggable:true });
    node.on('dragmove', ()=>{ constrainToCanvas(node, 6); playerLayer.batchDraw(); });
    node.on('mousedown', (e)=>{ if (mode==='select'){ clearSelection(); toggleSelection(node);} });
    playerLayer.add(node);
    return node;
  }

  function constrainToCanvas(node, padding){
    const nx = Math.min(BOARD_W - padding, Math.max(padding, node.x()));
    const ny = Math.min(BOARD_H - padding, Math.max(padding, node.y()));
    node.position({x:nx, y:ny});
  }

  function toggleSelection(node){
    const key = node._id;
    if (selected.has(key)){
      selected.delete(key);
      setSelectedStyle(node,false);
    }else{
      selected.add(key);
      setSelectedStyle(node,true);
    }
  }

  function setSelectedStyle(node, on){
    if (node instanceof Konva.Group){
      const circle = node.findOne('Circle');
      if (circle) circle.stroke(on ? '#ffffff' : '#00000055');
    } else if (node instanceof Konva.Circle){
      node.stroke(on ? '#ffffff' : '#00000066');
    } else if (node instanceof Konva.Arrow || node instanceof Konva.Line){
      node.stroke(on ? '#fff' : node.stroke());
    }
  }

  function clearSelection(){
    players.forEach(p => setSelectedStyle(p.node, false));
    if (ball) setSelectedStyle(ball, false);
    paths.forEach(p => setSelectedStyle(p.node,false));
    selected.clear();
  }

  function nearestPathPoint(points, x, y){
    let bestI = 0; let bestD = Infinity;
    for (let i=0;i<points.length;i+=2){
      const dx = points[i]-x, dy = points[i+1]-y; const d = dx*dx+dy*dy;
      if (d<bestD){bestD=d;bestI=i;}
    }
    return bestI;
  }

  // ------------------------------
  // POLUN PIIRTO
  // ------------------------------
  let drawingArrow = null;
  function startPath(x,y){
    drawingArrow = new Konva.Arrow({
      points:[x,y],
      stroke: currentColor, fill: currentColor, strokeWidth:3,
      pointerLength:10, pointerWidth:10, lineCap:'round', lineJoin:'round', tension:0.2
    });
    pathLayer.add(drawingArrow);
  }
  function addPointToPath(x,y){
    if (!drawingArrow) return;
    const pts = drawingArrow.points();
    pts.push(x,y);
    drawingArrow.points(pts);
    pathLayer.batchDraw();
  }
  function finishPath(){
    if (!drawingArrow) return;
    const pts = drawingArrow.points();
    if (pts.length < 4){ drawingArrow.destroy(); drawingArrow=null; pathLayer.draw(); return; }
    const node = drawingArrow;
    node.on('mousedown', (e)=>{
      if (mode==='select'){
        const multi = e.evt.shiftKey||e.evt.ctrlKey||e.evt.metaKey;
        if(!multi) clearSelection();
        toggleSelection(node);
      }
    });
    paths.push({ node, points: pts.slice() });
    drawingArrow = null;
    pathLayer.draw();
  }

  // ------------------------------
  // ANIMAATIO – pelaajat pitkin polkuja
  // ------------------------------
  async function animateSelection(){
    const selPlayers = players.filter(p=> selected.has(p.node._id));
    const selPaths = paths.filter(p=> selected.has(p.node._id));
    if (selPlayers.length===0 || selPaths.length===0){
      flashHint('Valitse ainakin yksi pelaaja ja yksi polku. (Vinkki: Shift monivalintaan)');
      return;
    }
    for (const p of selPlayers){
      const sx = p.node.x(), sy = p.node.y();
      let best = selPaths[0]; let bestDist = Infinity;
      for (const path of selPaths){
        const idx = nearestPathPoint(path.points, sx, sy);
        const dx = path.points[idx]-sx, dy = path.points[idx+1]-sy;
        const d = dx*dx+dy*dy; if (d<bestDist){bestDist=d;best=path;}
      }
      await animateAlong(p.node, best.points);
    }
  }

  function animateAlong(node, points){
    return new Promise(async resolve =>{
      const speed = 220; // px/s
      for (let i=0;i<points.length-2;i+=2){
        const x1 = i===0 ? node.x() : points[i];
        const y1 = i===0 ? node.y() : points[i+1];
        const x2 = points[i+2];
        const y2 = points[i+3];
        const dist = Math.hypot(x2-x1, y2-y1);
        const dur = dist / speed;
        await tweenTo(node, { x:x2, y:y2 }, dur);
      }
      node.draw();
      resolve();
    });
  }

  function tweenTo(node, props, duration){
    return new Promise(res=>{
      const tw = new Konva.Tween({ node, duration: Math.max(.1, duration), ...props, onFinish: ()=>{ tw.destroy(); res(); } });
      tw.play();
    });
  }

  // ------------------------------
  // TALLENNUS / LATAUS
  // ------------------------------
  function exportJSON(){
    const data = {
      players: players.map(p=>({ x: p.node.x(), y: p.node.y(), color: p.team, label: p.role })),
      ball: ball ? { x: ball.x(), y: ball.y() } : null,
      paths: paths.map(p=>({ points: p.points, color: p.node.stroke() }))
    };
    const blob = new Blob([JSON.stringify(data,null,2)], {type:'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'salibandy_taktiikat.json'; a.click();
    URL.revokeObjectURL(url);
  }

  function importJSON(file){
    const reader = new FileReader();
    reader.onload = (e)=>{
      const data = JSON.parse(e.target.result);
      clearAll();
      if (data.players){ data.players.forEach(p=> createPlayer(p.x, p.y, p.color, p.label)); }
      if (data.ball){ ball = createBall(data.ball.x, data.ball.y); }
      if (data.paths){
        data.paths.forEach(p=>{
          const arr = new Konva.Arrow({
            points: p.points, stroke: p.color || '#5ec8ff', fill: p.color || '#5ec8ff',
            strokeWidth:3, pointerLength:10, pointerWidth:10, lineCap:'round', lineJoin:'round', tension:0.2
          });
          arr.on('mousedown', (e)=>{ if (mode==='select'){ const multi = e.evt.shiftKey||e.evt.ctrlKey||e.evt.metaKey; if(!multi) clearSelection(); toggleSelection(arr);} });
          pathLayer.add(arr);
          paths.push({ node: arr, points: p.points.slice() });
        });
      }
      redrawAll();
    };
    reader.readAsText(file);
  }

  function clearAll(){
    clearSelection();
    players.forEach(p=> p.node.destroy()); players=[];
    paths.forEach(p=> p.node.destroy()); paths=[];
    if (ball){ ball.destroy(); ball=null; }
    redrawAll();
  }

  function redrawAll(){ pathLayer.draw(); playerLayer.draw(); }

  function flashHint(msg){
    const el = document.createElement('div');
    el.textContent = msg; el.className = 'toast';
    document.body.appendChild(el);
    setTimeout(()=>{ el.remove(); }, 2600);
  }

  // ------------------------------
  // TAPAHTUMAT
  // ------------------------------
  // Kenttäklikkaukset – lisää polun pisteitä tai pallo
  stage.on('mousedown', (e)=>{
    const pos = stage.getPointerPosition(); if (!pos) return;
    if (mode==='path'){
      if (!drawingArrow) startPath(pos.x, pos.y); else addPointToPath(pos.x, pos.y);
    } else if (mode==='ball' && !ball){ ball = createBall(pos.x, pos.y); playerLayer.draw(); }
  });

  // Tuplaklikkausta EI käytetä enää polun päättämiseen

  // Näppäimet
  window.addEventListener('keydown', (e)=>{
    if (e.key===' ' && mode==='path'){ e.preventDefault(); finishPath(); } // Space lopettaa polun
    if (e.key.toLowerCase()==='v'){ setMode('select'); }
    if (e.key.toLowerCase()==='p'){ setMode('path'); }
    if (e.key.toLowerCase()==='b'){ setMode('ball'); }
    if (e.key==='Delete' || e.key==='Backspace'){ deleteSelected(); }
  });

  function deleteSelected(){
    // Poista valitut polut/pelaajat/pallo
    paths = paths.filter(p=>{ if (selected.has(p.node._id)){ p.node.destroy(); return false; } return true; });
    players = players.filter(p=>{ if (selected.has(p.node._id)){ p.node.destroy(); return false; } return true; });
    if (ball && selected.has(ball._id)){ ball.destroy(); ball=null; }
    selected.clear(); redrawAll();
  }

  function setMode(m){
    mode = m; clearSelection();
    document.getElementById('selectModeBtn').setAttribute('aria-pressed', m==='select');
    document.getElementById('pathModeBtn').setAttribute('aria-pressed', m==='path');
    document.getElementById('ballModeBtn').setAttribute('aria-pressed', m==='ball');
  }
  setMode('select');

  // Painikkeet
  document.getElementById('addTeamsBtn').addEventListener('click', ()=>{
    // 5v5 ilman mv – roolit: VL, KH, OL, VP, OP
    // Vasemman puolen joukkue (sininen), muodostus kuten jääkiekossa:
    const midY = FIELD_MARGIN_Y + FIELD_H/2;
    const leftX_D = FIELD_MARGIN_X + 220; // puolustajat lähempänä omaa päätyä
    const leftX_F = FIELD_MARGIN_X + 320; // hyökkääjät edempänä

    // Puolustajat: VP (vasen), OP (oikea)
    createPlayer(leftX_D, midY-60, '#5ec8ff', 'VP');
    createPlayer(leftX_D, midY+60, '#5ec8ff', 'OP');

    // Hyökkääjät: VL (vasen laita), KH (keskus), OL (oikea laita)
    createPlayer(leftX_F, midY-90, '#5ec8ff', 'VL');
    createPlayer(leftX_F+60, midY,   '#5ec8ff', 'KH');
    createPlayer(leftX_F, midY+90, '#5ec8ff', 'OL');

    // Oikean puolen joukkue (pinkki), peilataan
    const rightX_D = FIELD_MARGIN_X + FIELD_W - 220;
    const rightX_F = FIELD_MARGIN_X + FIELD_W - 320;

    createPlayer(rightX_D, midY-60, '#ff7aa2', 'VP');
    createPlayer(rightX_D, midY+60, '#ff7aa2', 'OP');

    createPlayer(rightX_F, midY-90, '#ff7aa2', 'VL');
    createPlayer(rightX_F-60, midY,   '#ff7aa2', 'KH');
    createPlayer(rightX_F, midY+90, '#ff7aa2', 'OL');

    playerLayer.draw();
  });
  document.getElementById('clearBtn').addEventListener('click', clearAll);
  document.getElementById('saveBtn').addEventListener('click', exportJSON);
  document.getElementById('loadInput').addEventListener('change', (e)=>{ if (e.target.files && e.target.files[0]) importJSON(e.target.files[0]); e.target.value=''; });
  document.getElementById('animateBtn').addEventListener('click', animateSelection);
  document.getElementById('selectModeBtn').addEventListener('click', ()=> setMode('select'));
  document.getElementById('pathModeBtn').addEventListener('click', ()=> setMode('path'));
  document.getElementById('ballModeBtn').addEventListener('click', ()=> setMode('ball'));

  // Väripaletti poluille
  document.querySelectorAll('.color').forEach(el=>{
    el.addEventListener('click', ()=>{ currentColor = el.dataset.color; flashHint('Polun väri vaihdettu'); });
  });

  // Oletuspallo keskelle
  ball = createBall(FIELD_MARGIN_X + FIELD_W/2, FIELD_MARGIN_Y + FIELD_H/2);
  playerLayer.draw();

  // Responsiivinen skaalaus: säilytä koordinaatisto, skaalaa näkymää
  function fitStageIntoParent(){
    const parent = container.parentElement;
    const scale = Math.min(parent.clientWidth / BOARD_W, 560 / BOARD_H);
    const tx = (parent.clientWidth - BOARD_W * scale)/2;
    stage.width(BOARD_W * scale);
    stage.height(BOARD_H * scale);
    stage.scale({x:scale, y:scale});
    stage.x(tx); stage.draw();
  }
  window.addEventListener('resize', fitStageIntoParent);
  fitStageIntoParent();
  </script>
</body>
</html>
